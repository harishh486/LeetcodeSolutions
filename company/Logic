1. Longestsubstringwithoutrepition ==> sliding window problem
 keep one ptr and othe prt move until logic failes if logi fails
 increment left ptr and calcutae  length r-l or size of hash Map

2. ato i -- str conversion logic 
            int digit = str.charAt(i)-'0';
            result = result*10 + digit; 
            //ascii '1' -'0' = 0
            //ascii '9' - '0' = 9
3. twoSum -- a+b =target
       save in hashmap compliment a = target-b
       and get compliment

4. container probelem --max water -- max area problem
   brute force: 2 loops and calculate both area 
   2 ptss
   one at strt and other at end
   area = max( max,(min(h[i], h[j])* j-i))
   if h[i]< h[j} i++
   else  j--;
5.  int to roman ==> string declaration of arrays for ones tens thund thou
make string literal "" instead of '';
return thous[num/1000] + hund[(num%1000)/100] +tens [num%100/10] + num%10


6. Roman to Int 
  Keep a hashmap of roman and original
  Map<Character, Integre> hashmap
  initial result value = get hold of original right most value  s.length()-1 value in hashmap
  traverse from right to left 
  check i-1 and i index
  if i-1 >= i 
   then result = result + hm.get(s.charAt(i-1))
else 
then result = result - hm.get(s.charAt(i-1))

7. Three sum--  ***
   -- sort the arrays
   -- perform looping until lenth-2 since we need atleast 2 numbers  for a+b = -calculate
   --  identity duplicates and write the logi c for if not duplicates do this
   --logic 2 ptr code 
   -- keep target as sum and do 2 ptr thing  from i+1 and length-1
   i.e rest of the arrays
   -- if a+b = target satisfies then add all elements
   -- if a+b > target then reduce high--
       else low--
   --  Most important thing is removing duplicates with in elements not to process
       nums[low] == nums[low+1] then low++
       nums[high] == nums[high-1] then high--

8: StrStr(() --KMP -knuth morris-Pratt sunsstring problems)
   Naive- 2 for loops check every char in both string if not matches got back to nect string
   0(mn) --main string is processed too many times if mismatch

   mainyain 2 forloops 
     -- check only till the difference m-n
     -- inner loop check if str.charAt(i+j == substring.charAT(j)) then check if j is endof length then return i else return -1;
     --test cases emptyness,null etc
     -- 
     KMP
   --improvement can be done their, keep track of already visited
   --DNA identification if billions--efficient
   Breakdown:
   ---   ignore the big strig now and concentrate on substring and build a table of array 
   -- declare 2 indices i , j i=1, j=0
      final array = [-1,-1,-1]
      compare 
      check prefix =suffic or not
      if not restrat
      i does not go backj only go to back if nothing matches else it gos to already trversd 

9: 3 sum closest:
  // similar to 3 sum  and similar to 2 ptr concept
  //sort the array and do 2 pts thing
  // keep one fix and use i+1 and length-1 concept here also just like 3sum
  //maintain random result_sum with any random 3 values
  //iterate each value in loop :::iterate upto length-2 since we need atleast 2 numbers
  while(a_ptr< b_ptr)
  cal curr sum and compare with target and adjust a_ptr or b_ptr depends on comparison
  //Also most important one comapre the hop distance between currensum -target vs alreadyresultsum-target which ever is less tells that it is closest to target
  //so update the result sum with curr sum if smmallest
  if(Math.abs(currsum-target)< resultsum-target then assign resultsum=currsum)


10: Rotate matrix inolace:  --***
  simple use formula d[i][j]= src [src.length-1 -j][i] without inplace
  
   transpose and do reverse  each row of the resultant matrix after tarnpsoe
   row sto colums chnage
   then flip swap vaules with 2 pts approach
   1/ transpose 
   2. reverse
   3. 2 pts method 
   but inplace 

11. Group Anagrams
// defuine map string list
//iterate each str over array
//for each string
//conbvert to charArray and then sort and then convert back to string which acts a s a key
//now in map if key present  add the current string ur iterating else create a key with empty list and then add current string 
// once we fill all values we group all anagrams in list og map vaules map.values give s all values
//new Arraylist(map.values())--return list of lists



12: Min Window substring

// two pts:
// sliding minWindow
// 2 pts startss at same 
// L R e
// xpand the window by R++ if not satified
// once satified incremnet L by forwarding
// as soon as it fails the requiremnt again R++ until satified
// maintain  countarray for t string
//Algo is as follow:: maintain countarray for t string, then we compare s tring one by one maintaining 2 pts  by sliding window//
// left and right start at same times
//first satidfy the constraint by increasing the count

// then optimize for min window
when  count == t.lnth do
//l++ and r++ 
also count -- when we miss the requiremnt constraint increment l adn r

13:
  // have two numrcic int v1 and v2
  // convert each char in string to single digit and assign to v1 and v2
  //convert char to  digit using 
  v1= v1*10 + v.charAt(i)-'0 for both v1 and v2 
  an d then compare the digits v1 and v2
  if v1>v2 -->1 
  if v2>v1 -->-1

  else continue doing the same by i++,j++
  and also resetsing the earlier difits v1=v2=0;

  14: Product of array but itself:

   maintain left and right product for the current element  and then multiple
   left/outproduct[i]  = out/leftproduct[i-1]* nums[i-1]
initilaize o and N-1 =1 for both aarrays for i ->N-2 i>=0
   rightprd  = rightprd[i+1]* nums[i+1]

   R=1, out[0]=1
   left ==> outer[i] = outer[i-1]* nums[i-1]  for i -0;i<N
   right ==> outer[i] = outer[i] *R   ++> for i =N-1; i>=0
              R* nums[i]

  

  15: Missing num --***
   calculate sum and substrct from n(n-1)/2 -sum which give smissing numbers here n-1 becos it starts from 0 to n 




  16: find first  unique character  or first non repiting charcter index in s astring

   use hashmap == becos relate to count in a array or string
   iterate over the string 
   HashMap<Character, Integer> hm 
   hm.put(c, h.getOrDeafult(c,0) +1)

   once we build hashmap
   then iterate over to check get(c)  ==1 if so return index else -1

   Build hashmap 
// and traverse the hashmap with value ==1 then return index



17: Valid Parantheses: ****
===================

--famous stack reference problem
--bracket matching probelm 
-- order of closing important

-- quick check if string length is not even return failes
loop thru string

if u find the open brace for any brace --push it
when u find the closing brce , check the top of the stack if it matches then pop it else return false
opening--push
closing brace- not emptystack,
               peek and  if matches then
               pop


18: Most Common  word problem:
 ---make the lowercase
 --split the paragraph and 
-- use regex(\\W+) for non word characters and + is more 
use hashset to get quickly instead of for ;loops
--use hashmap-for each word and maintain count--classic count poroblem

--take the split  words and put it in hashmapbut 
    --befor eputting check if its a banned word, 
       -- if so dont put else put in map
       becos we need other than banned one and it should have max count

--once we build map then classic max problem --maintain max and update max thru loop and if it hit max
 tehn update result word


19: log reorder 

Instead of sorting in the default order, we'll sort in a custom order we specify.
The rules are:
Letter-logs come before digit-logs;
Letter-logs are sorted alphanumerically, by content then identifier;
Digit-logs remain in the same order.


https://medium.com/@scarletinked/are-you-the-leader-were-looking-for-interviewing-at-amazon-8301d787815d





