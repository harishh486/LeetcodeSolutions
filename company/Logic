1. Longestsubstringwithoutrepition ==> sliding window problem
 keep one ptr and othe prt move until logic failes if logi fails
 increment left ptr and calcutae  length r-l or size of hash Map

2. ato i -- str conversion logic 
            int digit = str.charAt(i)-'0';
            result = result*10 + digit; 
            //ascii '1' -'0' = 0
            //ascii '9' - '0' = 9
3. twoSum -- a+b =target
       save in hashmap compliment a = target-b
       and get compliment

4. container probelem --max water -- max area problem
   brute force: 2 loops and calculate both area 
   2 ptss
   one at strt and other at end
   area = max( max,(min(h[i], h[j])* j-i))
   if h[i]< h[j} i++
   else  j--;
5.  int to roman ==> string declaration of arrays for ones tens thund thou
make string literal "" instead of '';
return thous[num/1000] + hund[(num%1000)/100] +tens [num%100/10] + num%10


6. Roman to Int 
  Keep a hashmap of roman and original
  Map<Character, Integre> hashmap
  initial result value = get hold of original right most value  s.length()-1 value in hashmap
  traverse from right to left 
  check i-1 and i index
  if i-1 >= i 
   then result = result + hm.get(s.charAt(i-1))
else 
then result = result - hm.get(s.charAt(i-1))

7. Three sum--
   -- sort the arrays
   -- perform looping until lenth-2 since we need atleast 2 numbers  for a+b = -calculate
   --  identity duplicates and write the logi c for if not duplicates do this
   --logic 2 ptr code 
   -- keep target as sum and do 2 ptr thing  from i+1 and length-1
   i.e rest of the arrays
   -- if a+b = target satisfies then add all elements
   -- if a+b > target then reduce high--
       else low--
   --  Most important thing is removing duplicates with in elements not to process
       nums[low] == nums[low+1] then low++
       nums[high] == nums[high-1] then high--

8: StrStr(() --KMP -knuth morris-Pratt sunsstring problems)
   Naive- 2 for loops check every char in both string if not matches got back to nect string
   0(mn) --main string is processed too many times if mismatch

   mainyain 2 forloops 
     -- check only till the difference m-n
     -- inner loop check if str.charAt(i+j == substring.charAT(j)) then check if j is endof length then return i else return -1;
     --test cases emptyness,null etc
     -- 
     KMP
   --improvement can be done their, keep track of already visited
   --DNA identification if billions--efficient
   Breakdown:
   ---   ignore the big strig now and concentrate on substring and build a table of array 
   -- declare 2 indices i , j i=1, j=0
      final array = [-1,-1,-1]
      compare 
      check prefix =suffic or not
      if not restrat
      i does not go backj only go to back if nothing matches else it gos to already trversd 





https://medium.com/@scarletinked/are-you-the-leader-were-looking-for-interviewing-at-amazon-8301d787815d





